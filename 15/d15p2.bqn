#! /usr/bin/env -S bqn -f

deque â† â€¢Import "deque.bqn"

SplitM â† (Â¬-Ëœ âŠ¢Ã— Â·+`Â»âŠ¸>)âŠ¸âŠ”

Load â† {{aâ€¿b: (>a)â€¿(âˆ¾b)} ""âŠ¸â‰¢Â¨âŠ¸SplitM â€¢FLines ð•©}
moveopts â† "^>v<"
deltas â† âŸ¨Â¯1â€¿0, rightâ†0â€¿1, 1â€¿0, leftâ†0â€¿Â¯1âŸ©
DoubleSquare â† {
  ð•Š '#': "##" ;
  ð•Š 'O': "[]" ;
  ð•Š '.': ".." ;
  ð•Š '@': "@."
}
Solve â† { ð•Š mapâ€¿moves:
  map (âˆ¾ DoubleSquareÂ¨)Ë˜â†©
  rpos0 â† âŠ‘ ('@'=map) /â—‹â¥Š â†•â‰¢map
  map '.'âŒ¾(rpos0âŠ¸âŠ‘)â†©
  moves (âŠâŸœdeltas moveoptsâŠ¸âŠ)â†©

  TryMove â† { d ð•Š rpos:
    rpos1 â† d+rpos
    visited â† âŸ¨rpos1âŸ©â€¢HashMapâŸ¨1âŸ©
    tocheck â† deque.Deque âŸ¨rpos1âŸ©
    tomove â† deque.Deque âŸ¨âŸ©

    Consider â† {
      ð•Š p: visited.Has p ? @ ;
      ð•Š p: p visited.Set 1 â‹„ tocheck.PushBack p â‹„ @
    }
    CheckSquare â† {
      Â· ð•Š '.': 1 ;
      Â· ð•Š '#': rpos1 â†© rpos
               tomove â†© deque.Deque âŸ¨âŸ©
               0 ;
      p ð•Š '[': tomove.PushFront p
               Consider d+p
               Consider right+d+p
               1 ;
      p ð•Š ']': tomove.PushFront left+p
               Consider left+d+p
               Consider d+p
               1
    }
    Step â† {ð•¤
      tocheck.IsEmpty@ ? 0 ;
      p CheckSquare (p â† tocheck.PopFront@) âŠ‘ map
    }
    MoveBox â† { ð•Š p:
      map '.'âŒ¾((p)âŠ¸âŠ‘)â†©
      map '.'âŒ¾((right+p)âŠ¸âŠ‘)â†©
      map '['âŒ¾((d+p)âŠ¸âŠ‘)â†©
      map ']'âŒ¾((right+d+p)âŠ¸âŠ‘)â†©
    }

    (Step)â€¢_while_(âŠ¢) 1
    MoveBoxÂ¨ tomove.Contents@
    rpos1
  }
  rpos0 TryMoveÂ´ âŒ½moves

  +Â´ 100â€¿1Ã— +Ë > ('['=map) /â—‹â¥Š â†•â‰¢map
}

â€¢Showâˆ˜Solveâˆ˜LoadÂ¨ â€¢args
