#! /usr/bin/env -S bqn -f

ToNats â† { ((>âŸœÂ«0âŠ¸â‰¤) / 0(0âŠ¸â‰¤Ã—Ã—âŸœ10âŠ¸+)`âŠ¢) 10âŠ¸â‰¤âŠ¸(Â¬âŠ¸Ã—-âŠ£) ğ•©-'0' }
SplitM â† (Â¬-Ëœ âŠ¢Ã— Â·+`Â»âŠ¸>)âŠ¸âŠ”
Load â† { âˆ¾Â¨ âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸SplitM ToNatsÂ¨ â€¢FLines ğ•© }

âŸ¨Xor48âŸ© â† {
  intbase â† 2â‹†52
  suffix â† Â¯1 â†‘ 64â€¿16â€¢bit._cast âŸ¨intbaseâŸ©
  ToBits â† (3 â†‘ 64â€¿16â€¢bit._castâˆ˜â‹ˆ) intbaseâŠ¸+
  FromBits â† (intbase -Ëœ âŠ‘âˆ˜(16â€¿64â€¢bit._cast)) âˆ¾âŸœsuffix
  Xor48 â‡ FromBits (16â€¢bit._xor)â—‹ToBits
}

RunProgram â† { ğ•Š âŸ¨aâ€¿bâ€¿c, programâŸ©:
  ip â† Â¯1 â‹„ output â† âŸ¨âŸ©

  Read â† {ğ•¤â‹„ (ip+â†©1) âŠ‘ program}
  LiteralOperand â† Read
  ComboOperand â† {
    ğ•Š 0: 0; ğ•Š 1: 1; ğ•Š 2: 2; ğ•Š 3: 3;
    ğ•Š 4: a; ğ•Š 5: b; ğ•Š 6: c; ! "invalid combo operand"
  }âˆ˜Read
  ExecuteInstruction â† {
    ğ•Š 0: a (a âŒŠâˆ˜Ã· 2â‹†ComboOperand)â†© ;
    ğ•Š 1: b LiteralOperandâŠ¸Xor48â†© ;
    ğ•Š 2: b (8|ComboOperand)â†© ;
    ğ•Š 3: ip1 â† (aâ‰ 0)â—¶âŸ¨{ğ•¤â‹„ip}, -âŸœ1âŸ© LiteralOperand@ â‹„ ipâ†©ip1 ;
    ğ•Š 4: b (câˆ˜Read)âŠ¸Xor48â†© ;
    ğ•Š 5: output âˆ¾âŸœ(8|ComboOperand)â†© ;
    ğ•Š 6: b (a âŒŠâˆ˜Ã· 2â‹†ComboOperand)â†© ;
    ğ•Š 7: c (a âŒŠâˆ˜Ã· 2â‹†ComboOperand)â†©
  }âˆ˜Read
  Terminated â† {ğ•¤â‹„ ip â‰¥ Â¯1+â‰ program}

  (ExecuteInstruction)â€¢_while_(Â¬Terminated) @

  output
}

Octalize â† 0 +âŸœ(8âŠ¸Ã—)Â´ âŒ½
Solve â† { ğ•Š âŸ¨Â·â€¿bâ€¿c, programâŸ©:
  RP â† { ğ•Š ao: RunProgram âŸ¨(Octalize ao)â€¿bâ€¿c, programâŸ© }
  SuffixMatch â† âŠ¢ â‰¡ (-âˆ˜â‰ )âŠ¸â†‘âŸœprogram
  TryExtend â† { ğ•Š ao: SuffixMatchâˆ˜RPÂ¨âŠ¸/ aoâŠ¸âˆ¾Â¨ â†•8 }
  Step â† { ğ•Š aos: âˆ¾ TryExtendÂ¨ aos }
  âŒŠÂ´ OctalizeÂ¨ (programâ‰¡RP)Â¨âŠ¸/ StepâŸ(â‰ program) âŸ¨âŸ¨âŸ©âŸ©
}

â€¢Showâˆ˜Solveâˆ˜LoadÂ¨ â€¢args
