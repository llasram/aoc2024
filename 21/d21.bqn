#! /usr/bin/env -S bqn -f

Load â† â€¢FLines

dchars â† "^.v"â€¿"<.>"
MakeOrder â† { ğ•Š raâ€¿ca:
  _Order_ â† {
    # Default is u/d before l/r, but we want l > d > u/r
    Â·â€¿c1 _ğ•£_ r2â€¿Â·: (c1=ca)âˆ§(r2=ra) ? âŒ½ ;  # Avoid gap
    r1â€¿Â· _ğ•£_ Â·â€¿c2: (r1=ra)âˆ§(c2=ca) ? âŠ¢ ;  # Avoid gap
    Â·â€¿c1 _ğ•£_ Â·â€¿c2: c2 < c1 ? âŒ½ ;  # left
    r1â€¿Â· _ğ•£_ r2â€¿Â·: r1 < r1 ? âŠ¢ ;  # down
    _ğ•£_: âŠ¢ # otherwise
  }
  order
}
_EncDelta â† { rc1 Order _ğ•£ rc2:
  d â† rc2 - rc1
  moves â† (|d) /Â¨ dchars â‹ˆâˆ˜âŠ‘ËœÂ¨ 1+Ã—d
  'A'âˆ¾Ëœ âˆ¾ rc1 _Order_ rc2 moves
}
NeitherSpace â† {' 'â€¿Â·ğ•ŠÂ·:0; Â·ğ•Š' 'â€¿Â·:0; 1}
MakeTransitions â† { ğ•Š keypad:
  coords â† â†•â‰¢keypad
  order â† MakeOrder âŠ‘ (' '=keypad) /â—‹â¥Š coords

  index â‡ â¥Škeypad
  table â‡ NeitherSpaceâ—¶âŸ¨".", (Order _EncDelta)â—‹(1âŠ¸âŠ‘)âŸ©âŒœËœ keypad â‹ˆÂ¨â—‹â¥Š coords
}

numeric â† MakeTransitions [
  "789"
  "456"
  "123"
  " 0A"
]
directional â† MakeTransitions [
  " ^A"
  "<v>"
]

EncodeKeypad â† { t ğ•Š seq:
  âˆ¾ <âˆ˜(âŠ‘âŸœt.table)Ë˜ 2â†•t.indexâŠ'A'âˆ¾seq
}

âŸ¨CountDirectionalâŸ© â† {
  âŸ¨index,tableâŸ© â† directional
  memo â† âŸ¨âŸ©â€¢HashMapâŸ¨âŸ©
  CountTransition â† {
    0 CT p: 1 ;
    d CT p: k â† dâ€¿p â‹„ {
      memo.Has k ? memo.Get k ;
      n â† +Â´ (d-1)âŠ¸CTË˜ 2â†•'A'âˆ¾(indexâŠp)âŠ‘table
      k memo.Set n
      n
    }
  }
  CountDirectional â‡ { d ğ•Š seq:
    +Â´ dâŠ¸CountTransitionË˜ 2â†•'A'âˆ¾seq
  }
}

CountStack â† { d ğ•Š seq:
  d CountDirectional numeric EncodeKeypad seq
}

Complexity â† { d ğ•Š code:
  num â† 0 +âŸœ(10âŠ¸Ã—)Â´ âŒ½ '0'-Ëœ Â¯1â†“ code
  len â† d CountStack code
  num Ã— len
}
Solve â† { ds ğ•Š codes:
  +Â´Ë˜ ds ComplexityâŒœ codes
}

â€¢ShowÂ¨âˆ˜(2â€¿25âŠ¸Solve)âˆ˜LoadÂ¨ â€¢args
